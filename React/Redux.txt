Redux - 

1. Single Source of Truth
2. State is read only (state never get modified)
3. Changes are made only using pure functions

Action => Root reducer (it is an pure function) => Store (it contains all state) => DOM changes

Flux Pattern (instead of MVC pattern)

Action => Dispatcher => Store => View => Action

import { provider } from 'react-redux'


action object
We always return new object so our component can be re-render

redux flow - 
Action => Middleware => Root Reducer => Store => Dom changes

npm install redux redux-logger react-redux


import {Provider} from 'react-redux';
add <Provider> in main <App> so every one can access store object
eg:- <Provider>
            <App>
        <Provider>

import { combineReducers } from 'redux';

import { createStore, applyMiddleware } from 'redux';
import logger from 'redux-logger';


import { connect } from 'react-redux'

connect is an higher order function which allow to modify our component.

mapStateToProps function - can be name anything but it is an standard


// Redux functional

npm i redux react-redux redux-logger

create store/store.js

import { compose, createStore, applyMiddleware } from 'redux'
import logger from 'redux-logger'
import { rootReducer } from './root-reducer'

const middleWares = [logger]
const composeEnhancers = compose(applyMiddleware(...middleWares))

export const store = createStore(rootReducer, undefine, composeEnhancers) // second argument is adition default state



-> root-reducer

create store/root-reducer.js

import { combineReducers } from 'redux'
import { userReducer } from './user/user.reducer'

export const rootReducer = combineReducers({
    user: userReducer,
})


-> userReducer

create store/user/user.reducer.js

import { USER_ACTION_TYPES } from './user.types'


const INITIAL_STATE = {
    currentUser: null;
}

export const userReducer = (state = INITIAL_STATE, action) => {

    const { type, payload } = action;

    switch(type) {
        case USER_ACTION_TYPES.SET_CURRENT_USER:
            return { ...state, currentUser: payload }
        default:
            return state
    }
}

-> user types

create store/user/user.types.js

export const USER_ACTION_TYPES = {
    SET_CURRENT_USER: 'SET_CURRENT_USER',
}

-> user Action

create store/user/user.action.js

import { createAction } from './utils'
import { USER_ACTION_TYPES } from './user.types'

export const setCurrentUser = (user) => {
    createAction(USER_ACTION_TYPES.SET_CURRENT_USER, user)
}


-> index.js

import { Provider } from 'react-redux'
import { store } from './store/store'

<Provider store={store}>
    <App />
</Provider>


-> App.js


import { setCurrentUser } from './store/user/user.action'
import { useDispatch } from 'react-redux'

const dispatch = useDispatch()

useEffect(() => {
    dispatch(setCurrentUser(user))
}, [dispatch])


-> Selector

import { useSelector } from 'react-redux'

const currentUser = useSelector((state) => state.user.currentUser)

OR

create stor/user/user.selector.js

export const selectCurrentUser = (state) => state.user.currentUser


on Navigation component -

const currentUser = useSelector(selectCurrentUser)


-> Middleware

const loggerMiddleware = (store) => (next) => (action) => {
    if(!action.type) {
        return next(action)
    }

    console.log('type', action.type)
    console.log('payload', action.payload)
    console.log('currentState', store.getstate())
    console.log('currentState', store.getstate())

    next(action)

    console.log('nextSate', store.getstate())
}


### Reselect

it is use for memoization of selector state - so it can prevent un-necessary render

npm i reselect

import { createSelector } from 'reselect'

const selectCategoryReducer = (state) => state.categories

export const selectCategories = createSelector(
    [selectCategoryReducer, selectCurrentUser],
    (categoriesSlice, currentUser) => categoriesSlice.categories
)


### Redux persist

npm i redux-persist

import { persistStore, persistReducer } from 'redux-persist'
import storage from 'redux-persist/lib/storage'

const persistConfig = {
    key: 'root',
    storage,
    blacklist: ['user'],
}

const persistReducer = persistReducer(persistConfig, rootReducer)

export const store = createStore(persistReducer, undefine, composeEnhancers)

export const persistor = persistStore(store)


in index.js
import { persistGate } from 'react-persist/integration/react'
import { persistor } from 

<Provider store={store}>
    <persistGate loading={renderSomethingWhileWaiting} persistor={persistor}>
        <App />
    </persistGate>
</Provider>


### Redux thunk

redux thunk allow action which are function

npm i redux-thunk

import thunk from 'redux-thunk'

const middleWares = [process.env.NODE_ENV !== 'production' && logger, thunk].filter(Boolean)

OR

const middleWares = [logger, thunk]
const composeEnhancers = compose(applyMiddleware(...middleWares))


inside action

export const fetchCategoriesStart = () => createAction(CATEGORIES_ACTION_TYPES.FETCH_CATEGORIES_START)
export const fetchCategoriesSuccess = () => createAction(CATEGORIES_ACTION_TYPES.FETCH_CATEGORIES_SUCCESS, categories)
export const fetchCategoriesFailed = () => createAction(CATEGORIES_ACTION_TYPES.FETCH_CATEGORIES_FAILED, error)

create thunk actions

export const fetchCategoriesAsync = () => aysnc (dispatch) => {
    dispatch(fetchCategoriesStart())
    try{
        const categoriesArray = await getCategoriesAndDocuments('categories')
        dispatch(fetchCategoriesSuccess(categoriesArray))
    } catch(error) {
        dispatch(fetchCategoriesFailed(error))
    }
}


### Redux Saga

sideeffect state managment

